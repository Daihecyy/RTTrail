/* tslint:disable */
/* eslint-disable */
/**
 * rttrail
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'token_type': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AccountType = {
    User: 'user',
    Moderator: 'moderator',
    Admin: 'admin'
} as const;

export type AccountType = typeof AccountType[keyof typeof AccountType];


/**
 * 
 * @export
 * @interface ChangePassword
 */
export interface ChangePassword {
    /**
     * 
     * @type {string}
     * @memberof ChangePassword
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePassword
     */
    'old_password': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePassword
     */
    'new_password': string;
}
/**
 * Information about RTTrail
 * @export
 * @interface CoreInformation
 */
export interface CoreInformation {
    /**
     * 
     * @type {boolean}
     * @memberof CoreInformation
     */
    'ready': boolean;
    /**
     * 
     * @type {string}
     * @memberof CoreInformation
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface EmailRecover
 */
export interface EmailRecover {
    /**
     * 
     * @type {string}
     * @memberof EmailRecover
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface MailMigration
 */
export interface MailMigration {
    /**
     * 
     * @type {string}
     * @memberof MailMigration
     */
    'new_email': string;
}
/**
 * 
 * @export
 * @interface ResetPassword
 */
export interface ResetPassword {
    /**
     * 
     * @type {string}
     * @memberof ResetPassword
     */
    'reset_token': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPassword
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @interface Result
 */
export interface Result {
    /**
     * 
     * @type {boolean}
     * @memberof Result
     */
    'success'?: boolean;
}
/**
 * Schema for user\'s model similar to user table in database
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {AccountType}
     * @memberof User
     */
    'account_type': AccountType;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_active': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created_on'?: string | null;
}


/**
 * 
 * @export
 * @interface UserActivate
 */
export interface UserActivate {
    /**
     * 
     * @type {string}
     * @memberof UserActivate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserActivate
     */
    'activation_token': string;
}
/**
 * The schema is used to send an account creation request.
 * @export
 * @interface UserRegister
 */
export interface UserRegister {
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'name': string;
}
/**
 * Simplified schema for user\'s model, used when getting all users
 * @export
 * @interface UserSimple
 */
export interface UserSimple {
    /**
     * 
     * @type {string}
     * @memberof UserSimple
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserSimple
     */
    'id': string;
    /**
     * 
     * @type {AccountType}
     * @memberof UserSimple
     */
    'account_type': AccountType;
    /**
     * 
     * @type {boolean}
     * @memberof UserSimple
     */
    'is_active': boolean;
}


/**
 * Schema for user update
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface UserUpdateAdmin
 */
export interface UserUpdateAdmin {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateAdmin
     */
    'email'?: string | null;
    /**
     * 
     * @type {AccountType}
     * @memberof UserUpdateAdmin
     */
    'account_type'?: AccountType | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateAdmin
     */
    'name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdateAdmin
     */
    'is_active'?: boolean | null;
}


/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint will update the user new email address. The user will need to use the confirmation code sent by the `/users/migrate-mail` endpoint.
         * @summary Migrate Mail Confirm
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginMigrateMailConfirm: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getLoginMigrateMailConfirm', 'token', token)
            const localVarPath = `/login/migrate-mail-confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Ask for a JWT access token using oauth password flow.  *username* and *password* must be provided  Note: the request body needs to use **form-data** and not json.
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLoginAccessToken: async (username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('postLoginAccessToken', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('postLoginAccessToken', 'password', password)
            const localVarPath = `/login/access-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activate the previously created account.  **token**: the activation token sent by email to the user
         * @summary Activate User
         * @param {UserActivate} userActivate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLoginActivate: async (userActivate: UserActivate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userActivate' is not null or undefined
            assertParamExists('postLoginActivate', 'userActivate', userActivate)
            const localVarPath = `/login/activate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userActivate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change a user password.  This endpoint will check the **old_password**, see also the `/users/reset-password` endpoint if the user forgot their password.
         * @summary Change Password
         * @param {ChangePassword} changePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLoginChangePassword: async (changePassword: ChangePassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePassword' is not null or undefined
            assertParamExists('postLoginChangePassword', 'changePassword', changePassword)
            const localVarPath = `/login/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will send a confirmation code to the user\'s new email address. He will need to use this code to confirm the change with `/users/confirm-mail-migration` endpoint.
         * @summary Migrate Mail
         * @param {MailMigration} mailMigration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLoginMigrateMail: async (mailMigration: MailMigration, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mailMigration' is not null or undefined
            assertParamExists('postLoginMigrateMail', 'mailMigration', mailMigration)
            const localVarPath = `/login/migrate-mail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthorizationCodeAuthentication required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "AuthorizationCodeAuthentication", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mailMigration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allow a user to start a password reset process.  If the provided **email** corresponds to an existing account, a password reset token will be sent. Using this token, the password can be changed with `/users/reset-password` endpoint
         * @summary Recover User
         * @param {EmailRecover} emailRecover 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLoginRecover: async (emailRecover: EmailRecover, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailRecover' is not null or undefined
            assertParamExists('postLoginRecover', 'emailRecover', emailRecover)
            const localVarPath = `/login/recover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailRecover, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset the user password, using a **reset_token** provided by `/users/recover` endpoint.
         * @summary Reset Password
         * @param {ResetPassword} resetPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLoginResetPassword: async (resetPassword: ResetPassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPassword' is not null or undefined
            assertParamExists('postLoginResetPassword', 'resetPassword', resetPassword)
            const localVarPath = `/login/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test access token
         * @summary Test Token
         * @param {AccountType | null} [accountType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLoginTestToken: async (accountType?: AccountType | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/login/test-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountType !== undefined) {
                localVarQueryParameter['account_type'] = accountType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint will update the user new email address. The user will need to use the confirmation code sent by the `/users/migrate-mail` endpoint.
         * @summary Migrate Mail Confirm
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoginMigrateMailConfirm(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginMigrateMailConfirm(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getLoginMigrateMailConfirm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Ask for a JWT access token using oauth password flow.  *username* and *password* must be provided  Note: the request body needs to use **form-data** and not json.
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLoginAccessToken(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLoginAccessToken(username, password, grantType, scope, clientId, clientSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.postLoginAccessToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Activate the previously created account.  **token**: the activation token sent by email to the user
         * @summary Activate User
         * @param {UserActivate} userActivate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLoginActivate(userActivate: UserActivate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Result>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLoginActivate(userActivate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.postLoginActivate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change a user password.  This endpoint will check the **old_password**, see also the `/users/reset-password` endpoint if the user forgot their password.
         * @summary Change Password
         * @param {ChangePassword} changePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLoginChangePassword(changePassword: ChangePassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Result>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLoginChangePassword(changePassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.postLoginChangePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint will send a confirmation code to the user\'s new email address. He will need to use this code to confirm the change with `/users/confirm-mail-migration` endpoint.
         * @summary Migrate Mail
         * @param {MailMigration} mailMigration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLoginMigrateMail(mailMigration: MailMigration, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLoginMigrateMail(mailMigration, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.postLoginMigrateMail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allow a user to start a password reset process.  If the provided **email** corresponds to an existing account, a password reset token will be sent. Using this token, the password can be changed with `/users/reset-password` endpoint
         * @summary Recover User
         * @param {EmailRecover} emailRecover 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLoginRecover(emailRecover: EmailRecover, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Result>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLoginRecover(emailRecover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.postLoginRecover']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset the user password, using a **reset_token** provided by `/users/recover` endpoint.
         * @summary Reset Password
         * @param {ResetPassword} resetPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLoginResetPassword(resetPassword: ResetPassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Result>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLoginResetPassword(resetPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.postLoginResetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test access token
         * @summary Test Token
         * @param {AccountType | null} [accountType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLoginTestToken(accountType?: AccountType | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLoginTestToken(accountType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.postLoginTestToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * This endpoint will update the user new email address. The user will need to use the confirmation code sent by the `/users/migrate-mail` endpoint.
         * @summary Migrate Mail Confirm
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginMigrateMailConfirm(token: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getLoginMigrateMailConfirm(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Ask for a JWT access token using oauth password flow.  *username* and *password* must be provided  Note: the request body needs to use **form-data** and not json.
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLoginAccessToken(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<AccessToken> {
            return localVarFp.postLoginAccessToken(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Activate the previously created account.  **token**: the activation token sent by email to the user
         * @summary Activate User
         * @param {UserActivate} userActivate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLoginActivate(userActivate: UserActivate, options?: RawAxiosRequestConfig): AxiosPromise<Result> {
            return localVarFp.postLoginActivate(userActivate, options).then((request) => request(axios, basePath));
        },
        /**
         * Change a user password.  This endpoint will check the **old_password**, see also the `/users/reset-password` endpoint if the user forgot their password.
         * @summary Change Password
         * @param {ChangePassword} changePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLoginChangePassword(changePassword: ChangePassword, options?: RawAxiosRequestConfig): AxiosPromise<Result> {
            return localVarFp.postLoginChangePassword(changePassword, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will send a confirmation code to the user\'s new email address. He will need to use this code to confirm the change with `/users/confirm-mail-migration` endpoint.
         * @summary Migrate Mail
         * @param {MailMigration} mailMigration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLoginMigrateMail(mailMigration: MailMigration, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postLoginMigrateMail(mailMigration, options).then((request) => request(axios, basePath));
        },
        /**
         * Allow a user to start a password reset process.  If the provided **email** corresponds to an existing account, a password reset token will be sent. Using this token, the password can be changed with `/users/reset-password` endpoint
         * @summary Recover User
         * @param {EmailRecover} emailRecover 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLoginRecover(emailRecover: EmailRecover, options?: RawAxiosRequestConfig): AxiosPromise<Result> {
            return localVarFp.postLoginRecover(emailRecover, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset the user password, using a **reset_token** provided by `/users/recover` endpoint.
         * @summary Reset Password
         * @param {ResetPassword} resetPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLoginResetPassword(resetPassword: ResetPassword, options?: RawAxiosRequestConfig): AxiosPromise<Result> {
            return localVarFp.postLoginResetPassword(resetPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Test access token
         * @summary Test Token
         * @param {AccountType | null} [accountType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLoginTestToken(accountType?: AccountType | null, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.postLoginTestToken(accountType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * This endpoint will update the user new email address. The user will need to use the confirmation code sent by the `/users/migrate-mail` endpoint.
     * @summary Migrate Mail Confirm
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getLoginMigrateMailConfirm(token: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getLoginMigrateMailConfirm(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Ask for a JWT access token using oauth password flow.  *username* and *password* must be provided  Note: the request body needs to use **form-data** and not json.
     * @summary Login For Access Token
     * @param {string} username 
     * @param {string} password 
     * @param {string | null} [grantType] 
     * @param {string} [scope] 
     * @param {string | null} [clientId] 
     * @param {string | null} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postLoginAccessToken(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).postLoginAccessToken(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activate the previously created account.  **token**: the activation token sent by email to the user
     * @summary Activate User
     * @param {UserActivate} userActivate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postLoginActivate(userActivate: UserActivate, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).postLoginActivate(userActivate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change a user password.  This endpoint will check the **old_password**, see also the `/users/reset-password` endpoint if the user forgot their password.
     * @summary Change Password
     * @param {ChangePassword} changePassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postLoginChangePassword(changePassword: ChangePassword, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).postLoginChangePassword(changePassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will send a confirmation code to the user\'s new email address. He will need to use this code to confirm the change with `/users/confirm-mail-migration` endpoint.
     * @summary Migrate Mail
     * @param {MailMigration} mailMigration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postLoginMigrateMail(mailMigration: MailMigration, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).postLoginMigrateMail(mailMigration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allow a user to start a password reset process.  If the provided **email** corresponds to an existing account, a password reset token will be sent. Using this token, the password can be changed with `/users/reset-password` endpoint
     * @summary Recover User
     * @param {EmailRecover} emailRecover 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postLoginRecover(emailRecover: EmailRecover, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).postLoginRecover(emailRecover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset the user password, using a **reset_token** provided by `/users/recover` endpoint.
     * @summary Reset Password
     * @param {ResetPassword} resetPassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postLoginResetPassword(resetPassword: ResetPassword, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).postLoginResetPassword(resetPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test access token
     * @summary Test Token
     * @param {AccountType | null} [accountType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postLoginTestToken(accountType?: AccountType | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).postLoginTestToken(accountType, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CoreApi - axios parameter creator
 * @export
 */
export const CoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Favicon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaviconIco: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/favicon.ico`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return information about rttrail. This endpoint can be used to check if the API is up.
         * @summary Read Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInformation: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/information`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return RTTrail privacy
         * @summary Read Privacy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrivacy: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/privacy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return RTTrail robots.txt file
         * @summary Read Robots Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRobotsTxt: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/robots.txt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return RTTrail security.txt file
         * @summary Read Security Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurityTxt: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/security.txt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a style file from the assets folder
         * @summary Get Style File
         * @param {string} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStylefileCss: async (file: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('getStylefileCss', 'file', file)
            const localVarPath = `/style/{file}.css`
                .replace(`{${"file"}}`, encodeURIComponent(String(file)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return RTTrail terms and conditions pages
         * @summary Read Support
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupport: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/support`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return RTTrail terms and conditions pages
         * @summary Read Terms And Conditions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTermsAndConditions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/terms-and-conditions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return RTTrail security.txt file
         * @summary Read Wellknown Security Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWellKnownSecurityTxt: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/.well-known/security.txt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreApi - functional programming interface
 * @export
 */
export const CoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoreApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Favicon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFaviconIco(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFaviconIco(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.getFaviconIco']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return information about rttrail. This endpoint can be used to check if the API is up.
         * @summary Read Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInformation(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoreInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInformation(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.getInformation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return RTTrail privacy
         * @summary Read Privacy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrivacy(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrivacy(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.getPrivacy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return RTTrail robots.txt file
         * @summary Read Robots Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRobotsTxt(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRobotsTxt(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.getRobotsTxt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return RTTrail security.txt file
         * @summary Read Security Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecurityTxt(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecurityTxt(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.getSecurityTxt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a style file from the assets folder
         * @summary Get Style File
         * @param {string} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStylefileCss(file: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStylefileCss(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.getStylefileCss']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return RTTrail terms and conditions pages
         * @summary Read Support
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupport(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupport(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.getSupport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return RTTrail terms and conditions pages
         * @summary Read Terms And Conditions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTermsAndConditions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTermsAndConditions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.getTermsAndConditions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return RTTrail security.txt file
         * @summary Read Wellknown Security Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWellKnownSecurityTxt(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWellKnownSecurityTxt(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.getWellKnownSecurityTxt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoreApi - factory interface
 * @export
 */
export const CoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoreApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Favicon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaviconIco(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getFaviconIco(options).then((request) => request(axios, basePath));
        },
        /**
         * Return information about rttrail. This endpoint can be used to check if the API is up.
         * @summary Read Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInformation(options?: RawAxiosRequestConfig): AxiosPromise<CoreInformation> {
            return localVarFp.getInformation(options).then((request) => request(axios, basePath));
        },
        /**
         * Return RTTrail privacy
         * @summary Read Privacy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrivacy(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getPrivacy(options).then((request) => request(axios, basePath));
        },
        /**
         * Return RTTrail robots.txt file
         * @summary Read Robots Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRobotsTxt(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getRobotsTxt(options).then((request) => request(axios, basePath));
        },
        /**
         * Return RTTrail security.txt file
         * @summary Read Security Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurityTxt(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getSecurityTxt(options).then((request) => request(axios, basePath));
        },
        /**
         * Return a style file from the assets folder
         * @summary Get Style File
         * @param {string} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStylefileCss(file: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getStylefileCss(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Return RTTrail terms and conditions pages
         * @summary Read Support
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupport(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getSupport(options).then((request) => request(axios, basePath));
        },
        /**
         * Return RTTrail terms and conditions pages
         * @summary Read Terms And Conditions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTermsAndConditions(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getTermsAndConditions(options).then((request) => request(axios, basePath));
        },
        /**
         * Return RTTrail security.txt file
         * @summary Read Wellknown Security Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWellKnownSecurityTxt(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getWellKnownSecurityTxt(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoreApi - object-oriented interface
 * @export
 * @class CoreApi
 * @extends {BaseAPI}
 */
export class CoreApi extends BaseAPI {
    /**
     * 
     * @summary Get Favicon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public getFaviconIco(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).getFaviconIco(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return information about rttrail. This endpoint can be used to check if the API is up.
     * @summary Read Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public getInformation(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).getInformation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return RTTrail privacy
     * @summary Read Privacy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public getPrivacy(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).getPrivacy(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return RTTrail robots.txt file
     * @summary Read Robots Txt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public getRobotsTxt(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).getRobotsTxt(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return RTTrail security.txt file
     * @summary Read Security Txt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public getSecurityTxt(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).getSecurityTxt(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a style file from the assets folder
     * @summary Get Style File
     * @param {string} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public getStylefileCss(file: string, options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).getStylefileCss(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return RTTrail terms and conditions pages
     * @summary Read Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public getSupport(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).getSupport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return RTTrail terms and conditions pages
     * @summary Read Terms And Conditions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public getTermsAndConditions(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).getTermsAndConditions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return RTTrail security.txt file
     * @summary Read Wellknown Security Txt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public getWellKnownSecurityTxt(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).getWellKnownSecurityTxt(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeApi - axios parameter creator
 * @export
 */
export const MeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return `User` representation of current user  **The user must be authenticated to use this endpoint**
         * @summary Read Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthorizationCodeAuthentication required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "AuthorizationCodeAuthentication", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the profile picture of the authenticated user.
         * @summary Read Own Profile Picture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersMeProfilePicture: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/profile-picture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthorizationCodeAuthentication required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "AuthorizationCodeAuthentication", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the current user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value  **The user must be authenticated to use this endpoint**
         * @summary Update Current User
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUsersMe: async (userUpdate: UserUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('patchUsersMe', 'userUpdate', userUpdate)
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthorizationCodeAuthentication required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "AuthorizationCodeAuthentication", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will ask administrators to process to the user deletion. This manual verification is needed to prevent data from being deleting for other users
         * @summary Ask User Deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersMeAskDeletion: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/ask-deletion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthorizationCodeAuthentication required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "AuthorizationCodeAuthentication", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a profile picture for the current user.  **The user must be authenticated to use this endpoint**
         * @summary Create Current User Profile Picture
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersMeProfilePicture: async (image: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'image' is not null or undefined
            assertParamExists('postUsersMeProfilePicture', 'image', image)
            const localVarPath = `/users/me/profile-picture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication AuthorizationCodeAuthentication required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "AuthorizationCodeAuthentication", [], configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeApi - functional programming interface
 * @export
 */
export const MeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeApiAxiosParamCreator(configuration)
    return {
        /**
         * Return `User` representation of current user  **The user must be authenticated to use this endpoint**
         * @summary Read Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.getUsersMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the profile picture of the authenticated user.
         * @summary Read Own Profile Picture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersMeProfilePicture(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersMeProfilePicture(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.getUsersMeProfilePicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the current user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value  **The user must be authenticated to use this endpoint**
         * @summary Update Current User
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUsersMe(userUpdate: UserUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchUsersMe(userUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.patchUsersMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint will ask administrators to process to the user deletion. This manual verification is needed to prevent data from being deleting for other users
         * @summary Ask User Deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersMeAskDeletion(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersMeAskDeletion(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.postUsersMeAskDeletion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a profile picture for the current user.  **The user must be authenticated to use this endpoint**
         * @summary Create Current User Profile Picture
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersMeProfilePicture(image: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Result>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersMeProfilePicture(image, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.postUsersMeProfilePicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeApi - factory interface
 * @export
 */
export const MeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeApiFp(configuration)
    return {
        /**
         * Return `User` representation of current user  **The user must be authenticated to use this endpoint**
         * @summary Read Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersMe(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUsersMe(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the profile picture of the authenticated user.
         * @summary Read Own Profile Picture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersMeProfilePicture(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getUsersMeProfilePicture(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the current user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value  **The user must be authenticated to use this endpoint**
         * @summary Update Current User
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUsersMe(userUpdate: UserUpdate, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.patchUsersMe(userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will ask administrators to process to the user deletion. This manual verification is needed to prevent data from being deleting for other users
         * @summary Ask User Deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersMeAskDeletion(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postUsersMeAskDeletion(options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a profile picture for the current user.  **The user must be authenticated to use this endpoint**
         * @summary Create Current User Profile Picture
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersMeProfilePicture(image: File, options?: RawAxiosRequestConfig): AxiosPromise<Result> {
            return localVarFp.postUsersMeProfilePicture(image, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeApi - object-oriented interface
 * @export
 * @class MeApi
 * @extends {BaseAPI}
 */
export class MeApi extends BaseAPI {
    /**
     * Return `User` representation of current user  **The user must be authenticated to use this endpoint**
     * @summary Read Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public getUsersMe(options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).getUsersMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the profile picture of the authenticated user.
     * @summary Read Own Profile Picture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public getUsersMeProfilePicture(options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).getUsersMeProfilePicture(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the current user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value  **The user must be authenticated to use this endpoint**
     * @summary Update Current User
     * @param {UserUpdate} userUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public patchUsersMe(userUpdate: UserUpdate, options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).patchUsersMe(userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will ask administrators to process to the user deletion. This manual verification is needed to prevent data from being deleting for other users
     * @summary Ask User Deletion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public postUsersMeAskDeletion(options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).postUsersMeAskDeletion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a profile picture for the current user.  **The user must be authenticated to use this endpoint**
     * @summary Create Current User Profile Picture
     * @param {File} image 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public postUsersMeProfilePicture(image: File, options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).postUsersMeProfilePicture(image, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return all users from database as a list of `UserSimple`  **This endpoint is only usable by administrators**
         * @summary Read Users
         * @param {Array<AccountType>} [accountTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (accountTypes?: Array<AccountType>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthorizationCodeAuthentication required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "AuthorizationCodeAuthentication", [], configuration)

            if (accountTypes) {
                localVarQueryParameter['accountTypes'] = accountTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return all account types hardcoded in the system
         * @summary Get Account Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAccountTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/account-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthorizationCodeAuthentication required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "AuthorizationCodeAuthentication", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the number of users in the database  **This endpoint is only usable by administrators**
         * @summary Count Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthorizationCodeAuthentication required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "AuthorizationCodeAuthentication", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for a user using Jaro_Winkler distance algorithm. The `query` will be compared against users name, firstname and nickname. Assume that `query` is the beginning of a name, so we can capitalize words to improve results.  **The user must be authenticated to use this endpoint**
         * @summary Search Users
         * @param {string} query 
         * @param {Array<AccountType>} [includedAccountTypes] 
         * @param {Array<AccountType>} [excludedAccountTypes] 
         * @param {AccountType | null} [accountType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSearch: async (query: string, includedAccountTypes?: Array<AccountType>, excludedAccountTypes?: Array<AccountType>, accountType?: AccountType | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getUsersSearch', 'query', query)
            const localVarPath = `/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (includedAccountTypes) {
                localVarQueryParameter['includedAccountTypes'] = includedAccountTypes;
            }

            if (excludedAccountTypes) {
                localVarQueryParameter['excludedAccountTypes'] = excludedAccountTypes;
            }

            if (accountType !== undefined) {
                localVarQueryParameter['account_type'] = accountType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return `User` representation of user with id `user_id`  **The user must be authenticated to use this endpoint**
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersuserId: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersuserId', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthorizationCodeAuthentication required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "AuthorizationCodeAuthentication", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the profile picture of an user.  Unauthenticated users can use this endpoint (needed for some OIDC services)
         * @summary Read User Profile Picture
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersuserIdProfilePicture: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersuserIdProfilePicture', 'userId', userId)
            const localVarPath = `/users/{user_id}/profile-picture`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value  **This endpoint is only usable by administrators**
         * @summary Update User
         * @param {string} userId 
         * @param {UserUpdateAdmin} userUpdateAdmin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUsersuserId: async (userId: string, userUpdateAdmin: UserUpdateAdmin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('patchUsersuserId', 'userId', userId)
            // verify required parameter 'userUpdateAdmin' is not null or undefined
            assertParamExists('patchUsersuserId', 'userUpdateAdmin', userUpdateAdmin)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthorizationCodeAuthentication required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "AuthorizationCodeAuthentication", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateAdmin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a user
         * @summary User Register
         * @param {UserRegister} userRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersRegister: async (userRegister: UserRegister, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRegister' is not null or undefined
            assertParamExists('postUsersRegister', 'userRegister', userRegister)
            const localVarPath = `/users/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Return all users from database as a list of `UserSimple`  **This endpoint is only usable by administrators**
         * @summary Read Users
         * @param {Array<AccountType>} [accountTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(accountTypes?: Array<AccountType>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSimple>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(accountTypes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return all account types hardcoded in the system
         * @summary Get Account Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersAccountTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersAccountTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersAccountTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the number of users in the database  **This endpoint is only usable by administrators**
         * @summary Count Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for a user using Jaro_Winkler distance algorithm. The `query` will be compared against users name, firstname and nickname. Assume that `query` is the beginning of a name, so we can capitalize words to improve results.  **The user must be authenticated to use this endpoint**
         * @summary Search Users
         * @param {string} query 
         * @param {Array<AccountType>} [includedAccountTypes] 
         * @param {Array<AccountType>} [excludedAccountTypes] 
         * @param {AccountType | null} [accountType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersSearch(query: string, includedAccountTypes?: Array<AccountType>, excludedAccountTypes?: Array<AccountType>, accountType?: AccountType | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSimple>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersSearch(query, includedAccountTypes, excludedAccountTypes, accountType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return `User` representation of user with id `user_id`  **The user must be authenticated to use this endpoint**
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersuserId(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersuserId(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersuserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the profile picture of an user.  Unauthenticated users can use this endpoint (needed for some OIDC services)
         * @summary Read User Profile Picture
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersuserIdProfilePicture(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersuserIdProfilePicture(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersuserIdProfilePicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value  **This endpoint is only usable by administrators**
         * @summary Update User
         * @param {string} userId 
         * @param {UserUpdateAdmin} userUpdateAdmin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUsersuserId(userId: string, userUpdateAdmin: UserUpdateAdmin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchUsersuserId(userId, userUpdateAdmin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.patchUsersuserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a user
         * @summary User Register
         * @param {UserRegister} userRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersRegister(userRegister: UserRegister, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Result>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersRegister(userRegister, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.postUsersRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Return all users from database as a list of `UserSimple`  **This endpoint is only usable by administrators**
         * @summary Read Users
         * @param {Array<AccountType>} [accountTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(accountTypes?: Array<AccountType>, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserSimple>> {
            return localVarFp.getUsers(accountTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Return all account types hardcoded in the system
         * @summary Get Account Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAccountTypes(options?: RawAxiosRequestConfig): AxiosPromise<Array<AccountType>> {
            return localVarFp.getUsersAccountTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Return the number of users in the database  **This endpoint is only usable by administrators**
         * @summary Count Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersCount(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getUsersCount(options).then((request) => request(axios, basePath));
        },
        /**
         * Search for a user using Jaro_Winkler distance algorithm. The `query` will be compared against users name, firstname and nickname. Assume that `query` is the beginning of a name, so we can capitalize words to improve results.  **The user must be authenticated to use this endpoint**
         * @summary Search Users
         * @param {string} query 
         * @param {Array<AccountType>} [includedAccountTypes] 
         * @param {Array<AccountType>} [excludedAccountTypes] 
         * @param {AccountType | null} [accountType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSearch(query: string, includedAccountTypes?: Array<AccountType>, excludedAccountTypes?: Array<AccountType>, accountType?: AccountType | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserSimple>> {
            return localVarFp.getUsersSearch(query, includedAccountTypes, excludedAccountTypes, accountType, options).then((request) => request(axios, basePath));
        },
        /**
         * Return `User` representation of user with id `user_id`  **The user must be authenticated to use this endpoint**
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersuserId(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUsersuserId(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the profile picture of an user.  Unauthenticated users can use this endpoint (needed for some OIDC services)
         * @summary Read User Profile Picture
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersuserIdProfilePicture(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getUsersuserIdProfilePicture(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value  **This endpoint is only usable by administrators**
         * @summary Update User
         * @param {string} userId 
         * @param {UserUpdateAdmin} userUpdateAdmin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUsersuserId(userId: string, userUpdateAdmin: UserUpdateAdmin, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.patchUsersuserId(userId, userUpdateAdmin, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a user
         * @summary User Register
         * @param {UserRegister} userRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersRegister(userRegister: UserRegister, options?: RawAxiosRequestConfig): AxiosPromise<Result> {
            return localVarFp.postUsersRegister(userRegister, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Return all users from database as a list of `UserSimple`  **This endpoint is only usable by administrators**
     * @summary Read Users
     * @param {Array<AccountType>} [accountTypes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(accountTypes?: Array<AccountType>, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(accountTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return all account types hardcoded in the system
     * @summary Get Account Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersAccountTypes(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersAccountTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the number of users in the database  **This endpoint is only usable by administrators**
     * @summary Count Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersCount(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for a user using Jaro_Winkler distance algorithm. The `query` will be compared against users name, firstname and nickname. Assume that `query` is the beginning of a name, so we can capitalize words to improve results.  **The user must be authenticated to use this endpoint**
     * @summary Search Users
     * @param {string} query 
     * @param {Array<AccountType>} [includedAccountTypes] 
     * @param {Array<AccountType>} [excludedAccountTypes] 
     * @param {AccountType | null} [accountType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersSearch(query: string, includedAccountTypes?: Array<AccountType>, excludedAccountTypes?: Array<AccountType>, accountType?: AccountType | null, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersSearch(query, includedAccountTypes, excludedAccountTypes, accountType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return `User` representation of user with id `user_id`  **The user must be authenticated to use this endpoint**
     * @summary Read User
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersuserId(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersuserId(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the profile picture of an user.  Unauthenticated users can use this endpoint (needed for some OIDC services)
     * @summary Read User Profile Picture
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersuserIdProfilePicture(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersuserIdProfilePicture(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value  **This endpoint is only usable by administrators**
     * @summary Update User
     * @param {string} userId 
     * @param {UserUpdateAdmin} userUpdateAdmin 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public patchUsersuserId(userId: string, userUpdateAdmin: UserUpdateAdmin, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).patchUsersuserId(userId, userUpdateAdmin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a user
     * @summary User Register
     * @param {UserRegister} userRegister 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsersRegister(userRegister: UserRegister, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).postUsersRegister(userRegister, options).then((request) => request(this.axios, this.basePath));
    }
}



